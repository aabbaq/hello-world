# JVM

用来学习JVM的简略笔记，虽然已经有人做过了，但是不适合自己理解，因此还是自己写一些笔记比较好，有些内容抄的别人的资料，[配色方案](https://roselia.moe/blog/post/how-to-be-a-dd)也是抄的。总之<font color="#fb5458">红色部分的内容需要重新思考或者慎重的理解</font>，而且用的是标签的标记方法，可能等我摸透了扩展语法的内联公式再来修改吧。

- [别人的笔记](https://github.com/TangBean/understanding-the-jvm)

## 类加载

### 生命周期

```
加载阶段 --> 链接阶段 --> 初始化阶段
```

1. **加载：**

   这个过程会把字节码文件，即 `.class` 文件读入内存，并将其中的**静态结构**转化为**运行时数据结构**，生成的内存**class对象**放入方法区。最开始的步骤，更官方的说法是通过类的**全限定名**获取定义此类的**二进制字节流**。

   - 读入内存也就是加载（load）文件，这里的文件就是存在于网络或者物理存储中的文件，这个过程需要类加载器（ClassLoader）去实现。
   - 运行时的类信息，不仅包含类的基本信息，还包含**运行时常量池**信息，字符串字面量，数字常量，这些信息也是从 `.class` 文件中**常量池**这个部分读取或者说加载的。 
   - <font color="#fb5458">个人推断和理解</font>：方法区的class对象就是与static相关的这个对象，每个类只有一个，而实例肯定是不同的，没有新建实例的情况下，不可访问其属性。

2. **链接：**

   1. 验证：

      验证加载的 `.class` 文件中的字节流是否符合虚拟机要求，比如验证 `.class` 文件起始是否为**魔数**`CAFEBABE`，各个区域的语义，逻辑是否合乎规范等，有几个步骤（或者是种类的验证），但是感觉不大重要。
      
      - <font color="#fb5458">疑惑</font>：这里的描述是 `.class` 文件的字节流，但是第一步加载已经加载进内存了，这时验证是否不大合理？还是说是一遍加载一遍验证的，很怪。
   
   2. 准备：
   
      简单来说，是为**类变量**进行初始的**默认值**赋值，也就是 `static` 变量，根据其类型分别赋不同的值。<font color="#fb5458">这个过程也包含了内存分配的过程</font>
   
      - 但是对于 `final` 这种常量，在编译阶段，<font color="#fb5458">这个值大概会直接写好在 `.class` 内部</font>，然后这个时候直接显示初始化为该值，就没有默认值这一个说法了。
      - 至于为什么常量会在该阶段直接完成赋值操作，原因很简单：常量赋值过后不会被**修改**，所以直接在<font color="#fb5458">定义时</font>就给予值了。
   
   3. 解析：
   
      **常量池**内的符号引用转化为直接引用的过程？其中**符号引用**指用一组符号描述所引用的对象，引用目标不一定在内存中，而**直接引用**直接指向，如被引用目标在内存中的位置的指针，又或者是相对偏移量等。说实话这个解释没看懂。

3. **初始化**

   执行类构造器 `<clinit>()` 方法的过程。这个过程会自动收集类变量（ `static` 变量）的初始化语句，以及静态代码块的语句，整合到一起组成一个 `<clinit>()` 方法，然后执行。实际上就是初始化所有需要初始化的**变量**。

   - 需要注意的地方是，该方法按照代码语句顺序依次执行，常说的一种特殊例子，类似于先写静态代码块语句为还没有声明的类变量赋值，在下方才声明类变量，这个写法是可以的。原因在于，在**链接**阶段的准备环节，所有的类变量均已分配好内存空间，并赋予了初始值，那么在初始化阶段，这个类变量就会依次被静态代码块，自己声明的赋值所赋值，造成的结果就是静态代码块中的赋值没有用。*不过，如果不是赋值操作，那么编译器会报错（不能访问）*。
   - 如果没有类变量或者静态代码块，那么就不会生成  `<clinit>()` 方法，不过，对于 `<init>()` 一定会存在。并且，调用 `<clinit>()` 前，会调用其父类的  `<clinit>()` 方法。如果有多个线程都尝试加载同一个类时，需要加锁，不然内存中会存在两个class对象，并且这个对象也只会存在一个。

---

### 类加载器

<font color="#fb5458">可分为2大类，4小类</font>，两个大类指启动类加载器（Bootstrap）以及其他加载器，其原因是启动类加载器是C/C++编写的，其他的都继承于Java的类。

`应用程序类加载器 => 扩展类加载器 => 启动类加载器` ，按照层级，右侧的加载器成为**父**类加载器，注意是 **父** 加载器，而不是 **父类** 加载器，并不是**继承关系**。

- **启动类加载器/引导类加载器（Bootstrap）**：由C/C++实现，核心类库的加载器；
- **扩展类加载器（Extension）**：加载 `jre/lib/ext` 目录下的类；
- **应用程序类加载器/系统类加载器（Application）**：负责加载环境变量 `classpath` 或系统属性指定路径下的类库，一般自己写的类由这个加载器负责加载；
- 用户自定义类加载器：暂无；

### 双亲委派

按照层级，当前类加载器会不断地将加载任务交给**父**类加载器，直到顶层加载器，如果该加载器能够加载，则加载，不能就向下交给**子**类加载器加载。这样可以防止自己写的代码覆盖掉需要**启动类加载器**加载的核心类库，最常见的例子是自己写一个 `String` 类，并尝试加载。由此引出的概念是**沙箱安全机制**，即保护核心类库的代码不会被外部代码篡改。

---

## 运行时数据区

### Java线程

Java线程对应了操作系统的内核线程（Hotspot JVM）

---

### 程序计数器 （PC寄存器）

对物理寄存器的一种抽象，或者模拟，占用内存空间小，存在于每个线程中，程序计数器的作用是**行号指示**，存放下一条指令的地址（即将执行的指令代码）。

- 是唯一没有**OOM**的区域，也不会GC
- 既然是寄存器的模拟，那么程序计数器可以完成线程上下文切换的状态保存作用，这样就可以继续工作了

---

### 虚拟机栈

名称为Java虚拟机栈，由**栈帧**组成，每个栈帧对应一个Java方法。

- 存放**局部变量**，包含基本数据类型，或者对象的引用地址

- 指令集小，但完成操作需要的指令较多；采用栈的设计主要是为了跨平台。
- 不存在GC，但会OOM
- 可能出现两种异常：
  1. StackOverflowError：线程申请的栈空间超过了虚拟机栈允许的最大容量
  2. OutOfMemoryError：如果栈空间可以动态扩展，但内存中没有空间可以被扩展时；
- 可以使用 `-Xss SIZE`：设定虚拟机栈的大小，默认以字节作为单位，可以添加 `k m g` 来设置不同级别的的栈大小

#### 栈帧结构

1. 局部变量表（Local Variables）

   - **表大小**（长度）在编译完成后即确定，运行时**不会改变**；
   - LineNumberTable：字节码指令行号（Start PC）与代码行号的对应表；
   - LocalVariableTable：字节码指令行号表示声明变量的作用范围（下一行开始）；
   - 因为变量大小并不一定都一致，局部变量表内部，针对不同的变量需要占用不同空间，这个空间单位叫做**插槽（Slot）**，32位以内类型占用1个，64位占用2个；
     - 引用类型、与其他基本类型占用1个slot，并且能转化为int类型的其他类型转化为int类型
     - long、double占用2个slot；
   - 如果为**非静态**方法（构造方法，实例方法），需要增加实例的**this变量**至局部变量表内的**索引0**位置，即使有**形参**的声明，也是this在索引0位置
   - **重复利用**的优化：如果中间有局部变量的生命周期结束（比如局部变量中的局部变量），那么这个空余的插槽如果可以为后续的变量使用，那么分配给后续的变量以节省资源。

2. 操作数栈/表达式栈（Operand Stack）

   - 栈大小在编译后就确定了，操作数栈是一个数组结构

   - 保存计算过程的中间结果，可以看成一个临时的存储空间
   - 方法的返回值也会被保存在操作数栈中

3. 动态链接/指向运行时常量池的方法引用（Dynamic Link）
   - 引用的目的是支持当前方法的代码能够实现动态链接
   - 在编译完成后，所有的变量与方法都保存在class文件的常量池里（作为符号引用），而动态链接会将这些嵌套的符号引用转换为调用方法的直接引用
   - 可以理解为一个指向方法区运行时常量池的指针


4. 方法返回地址（Return Address）
   - 存放当前程序计数器的值，即该方法被调用时的位置（在正常退出的情况下）

5. 其他

---

### 本地方法栈

类似于虚拟机栈，但是调用的方法为本地方法，如C方法

- 不受JVM的控制，可以访问更底层，也可以访问JVM的运行时数据区

---

### 堆

存储数组和对象的实例，堆空间可以在物理上不连续，但在逻辑上是连续的。对堆空间进行分代，或者说是区域划分主要是为了优化GC的性能

- 分为新生代，老年代以及元空间（老版本为永久代）
- 整体参数相关
  - `-Xms`：用于设置堆空间初始的内存大小，只包含新生代，老年代
  - `-Xmx`：用于设置堆空间最大的内存大小
  - 上述两种的方法可以加上相应的单位，如`k`，`m`；若不设置，在Windows系统中，堆内存初始内存为本地内存的1/64，最大内存为本地内存的1/4
  - `-XX:+PrintGCDetails`：显示垃圾回收的细节
- `jsp` | `jstat -gc PID`：查看Java进程的内存使用情况
- 会出现OOM，原因是内存使用情况超出了设置的堆空间最大值
- 新生代与老年代参数相关
  - `-XX:NewRatio=R`：设置新生代与老年代的占比，默认为2，2指的是老年代的比例数
  - `-XX:SurvivorRatio=R`：设置新生代中伊甸区与幸存者区的占比，默认为8，8指的是伊甸区大小占比
  - `-Xmn`：设置新生代空间大小
  - `-XX:MaxTenuringThreshold`：设置新生代晋升的最大年龄

#### 内存分配策略

- 一般情况下，分配至Eden区
- 过大对象或能断定存活时间长的对象直接放入老年代
- <font color="#fb5458">Survivor区中，从最小年龄至指定年龄的对象大小总和若大于S区总空间的一半，则大于或者等于该指定年龄的对象可以直接进入老年代（不需要达到年龄阈值）</font>
- TLAB的分配，优先考虑在此空间内分配内存
- <font color="#fb5458">如果经过逃逸分析后，如果对象不会逃逸，该对象可能会被分配在**栈**上？</font>

---

### 方法区

用于存储已被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等

- 大小可动态调整，JDK 8后不属于JVM，而存在于本地内存中

- `XX:MetaspaceSize`：默认为21M，但仅限于Windows平台
- `XX:MaxMetaspaceSize`：最大值，默认为-1，即不限制大小
- 触发GC的条件，达到高水平线，即 `MetaspaceSize` 的大小就会进行GC，然后根据GC释放的空间多少决定元空间的动态调整
  - 回收的主要内容是：
    - 常量池的废弃常量，一旦常量池的常量没有被其他位置引用，就可以回收，这些常量包括了类和接口的全限定名，字段名称与描述符，方法名称与描述符
    - 废弃的类，完全不会再用到的类，条件比较苛刻，例如所有的类实例需要都被回收，类加载器也已被回收，该类对应的 `java.lang.Class` 对象未被引用（无法通过反射访问类方法）




## 垃圾回收

### 分类

1. **部分回收**：收集部分Java堆分区的垃圾回收
   - **Minor GC**：新生代垃圾回收，只包含新生代（Eden，S0，S1）区域的回收
     - 触发方式为Eden区空间不足时
     - 发生频率较高，回收速度快
     - 会引发STW
   - **Major GC**：老年代的垃圾收集
     - <font color="#fb5458">不清楚什么时候发生</font>，但有对象从老年代消失时，可能发生了Major GC或者Full GC
     - STW比Minor GC长10倍以上
   - **Mixed GC**：收集新生代以及部分老年代的垃圾收集
   
2. **整堆回收**：收集整个Java堆（包含方法区）的垃圾收集

   - 触发方式可能为调用 `System.gc()`
   - 老年代或者方法区空间不足时
   - Minor GC后，老年代空间仍然不足时

   - 尽量避免Full GC，影响效率

> 如果发生Full GC或Major GC垃圾回收，内存空间还不足，会触发OOM

---

### 阶段

#### 标记阶段

- **引用计数法**
  - 实现简单，效率高，回收不会有延迟
  - 需要额外空间存储计数器，用于计算对象的（被）引用次数
  - 更新计数器需要额外开销
  - 不能处理循环引用的情况
- **可达性分析法**
  - 以GC Roots为起点，寻找可到达的对象，除此以外的为垃圾：
    - 虚拟机栈中引用的对象
    - 本地方法栈内JNI引用的对象
    - 方法区中静态属性引用的对象
    - 方法区中常量引用的对象
    - 同步锁持有的对象
    - 其他
  - 可能临时增加一些GC Roots

#### 清除阶段

- 标记清除法
  - **简单**，但是效率**不稳定**，需要**遍历整个空间**以获得标记的非垃圾对象
  - 适合**存活对象多**，**回收对象少**的场景
  - 会产生内存碎片
  - 需要维护一个空闲列表，通过空闲列表来判断内存是否可用
- 标记复制法
  - 效率高，只需要在可达性分析时就可以将非垃圾对象复制
  - 适合**存活对象少**的场景
  - 需要**额外的内存空间**（2倍）
  - 需要**担保机制**，为了保证空间够用，但空间不至于太大，需要控制S1与S2区的大小，若此时空间仍然不够用，需要从其他区域借一些空间，这被称为担保机制
  - 在垃圾不多的时候，效率不高（复制大量的非垃圾对象）
- 标记整理法（标记压缩法）
  - 不需要额外空间，也不存在内存碎片化的问题
  - 效率较低

### 策略

- 分代收集算法：根据不同内存区的大小，特征采用不同的垃圾收集策略
- 增量收集算法：在垃圾回收线程和用户线程之间来回执行，减少一次STW的时间
- 分区算法：合理地回收某个区域的垃圾，不同于大的分代策略，这种算法的分区更小（小区间）

### 垃圾回收器

七种经典垃圾回收器

- 串行回收器：Serial，Serial Old
- 并行回收器：ParNew，Parallel Scavenge，Parallel Old
- 并发回收器：CMS，G1

#### Serial & Serial Old

- 对于新生代采用标记复制法，串行回收以及STW机制

- 对于老年代，使用标记整理法（<font color="#fb5458">个人想法，在一些文章中说使用标记清除法，但是总会需要整理内存空间的，猜测小周期内使用标记清除，达到一定程度时使用标记整理，但是这里会不会算成Full GC呢</font>）
- 工作流程为，暂停所有工作线程，启动GC线程进行垃圾回收
- Serial Old可以与Parallel Scavenge配合使用，也可以作为CMS的后备方案
- 占用内存少，适合在单核环境下使用，但多核情况下不适用，一半交互性强的应用程序不会使用此类的收集器

#### ParNew

- 对于新生代的多线程并行回收器
- 与Serial回收器原理相同，但是为多线程收集，同理，使用标记复制法
- 与CMS配合使用

#### Parallel Scavenge & Parallel Old

- 吞吐量优先，尽可能提升吞吐量
- 底层框架和以往的回收器不同，不能配合使用
- 适合于后台运算，而不是交互的场景
- Parallel Scavenge使用标记复制法
- Parallel Old会使用标记整理法

#### CMS

- 低延迟，并发，低STW时间，使用标记清除法，老年代回收器
- 因为需要和用户线程并发执行，因此需要在达到阈值之前进行收集工作，如果无法分配内存，则使用后备方案进行垃圾收集
- 工作过程
  - 初始标记：STW，标记GC Root能**直接**关联到的对象，时间短，速度快
  - 并发标记：与用户线程并发执行，从之前的关联对象开始遍历，耗时较长
  - 重新标记：STW，修正之前并发标记过程中变动的对象
  - 并发清理：并发清除死亡对象，但是该过程中新的垃圾会产生，因此无法处理浮动垃圾
- 由于使用标记清除法，会产生内存碎片；对CPU资源敏感，并发阶段会占用一部分用户线程的资源；无法处理浮动垃圾，在并发标记阶段之后，用户线程产生的新的垃圾无法被清除

#### G1

- 特点

  - 在延迟可控的情况下，获得更高的吞吐量

  - 兼具并行与并发的特性，多个GC线程执行，拥有与用户线程并发执行的能力

  - 属于分代型垃圾收集器，不同的Region可以是不同的代或者区（类似于打上标签）

  - 宏观上看，是标记整理法，从单个Region看，是复制法

  - **可预测的停顿时间模型**，因为分区的原因，只选取部分分区进行垃圾回收，因此让停顿时间可控；通过维护优先列表，对不同**优先级的区域**进行垃圾回收，性价比高

  - 内存占用较高，面对服务端应用（要求**高响应性**），大内存，多处理器的使用场景下效果较好

- Region相关

  - Region大小为2的N次幂（如1MB，2MB，直到24MB），不会变动，整体数量固定
  - Region可以被分配为Eden，Survivor，或者Old区域
  - 特殊的Region为Humongous区，用于存放大对象（1.5个Region大小），单个H区无法存放时，需要寻找连续的H区，若还不能分配，则进行一次Full GC

- 回收过程

  - 新生代GC：当Eden区空间耗尽时，进行新生代GC，只会回收Eden区以及Survivor区，需要更新Rset，并参照之前的回收法进行回收
  - 并发标记：初始标记类似于CMS，标记直接可达对象，之后进行根区域扫描并进行并发标记，如果并发标记时发现区域内都是标记，则直接进行回收；接下来再次标记，修正结果
  - 混合回收：...
  - 后备回收方案：Full GC

## 对象相关

**创建对象的方式：**

1. `new` 使用关键字创建对象，或者使用类中提供的方法获得对象实例
2. `Class` 的 `newInstance()` 利用反射创建对象
3. `Constructor` 的 `newInstance()` 反射创建
4. `clone()` 不调用构造器，但需要实现该方法
5. 反序列化，获取二进制流
6. 其他

---

**创建对象的步骤：**

1. 加载类 元信息
2. 为对象分配内存
3. 处理并发问题
4. 属性初始化（默认值）
5. 设置对象头信息
6. 显式初始化属性，例如代码块，构造器中的赋值

---

**内存结构**

- 对象头
  - 运行时元数据（Mark Word）
  - 类型指针，指向类元数据，用于确定对象的所属类型
- 实例数据
  - 存储有效信息，父类定义的变量会出现在子类之前
- 对齐填充

---

**引用类型**

- 强引用：最常用的引用，如果存在强引用的关系，就不会被垃圾回收
  - 常见的引用类型，也是默认的引用类型
  - 是造成Java内存泄漏的主要原因
- 软引用：即将发生内存溢出时，才会将软引用对象列入回收目标中
  - 主要目的是为了实现高速缓存
- 弱引用：弱引用的对象在下一次垃圾收集器工作时，会被回收
  - 可指定引用队列跟踪其情况
  - 垃圾回收线程优先级很低，不一定能发现弱引用对象
  - 但正常情况下，弱引用比软引用更快更容易被垃圾回收
- 虚引用：不会对生命周期构成影响，但是该种对象被收集器回收时，会通知系统
  - 使用虚引用无法获取被引用的对象
  - 必须使用引用队列，当持有虚引用的对象被回收时，虚引用会被加入队列，以此来跟踪记录

---

## String

一些特性，实现了序列化接口，并且实现了可比较接口，定义为 `final` 类，不可被继承

声明可以用字面量声明，也可以使用 `new` 关键字声明。jdk8之前使用 `char[]` 作为底层存储，jdk9之后改为 `byte[]`

- 字符串常量池是一个固定大小的Hashtable中


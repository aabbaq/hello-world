# JVM

用来学习JVM的简略笔记，虽然已经有人做过了，但是不适合自己理解，因此还是自己写一些笔记比较好，有些内容抄的别人的资料，[配色方案](https://roselia.moe/blog/post/how-to-be-a-dd)也是抄的。总之<font color="#fb5458">红色部分的内容需要重新思考或者慎重的理解</font>，而且用的是标签的标记方法，可能等我摸透了扩展语法的内联公式再来修改吧。

- [别人的笔记](https://github.com/TangBean/understanding-the-jvm)

## 类加载

### 生命周期

```
加载阶段 --> 链接阶段 --> 初始化阶段
```

1. **加载：**

   这个过程会把字节码文件，即 `.class` 文件读入内存，并将其中的**静态结构**转化为**运行时数据结构**，生成的内存**class对象**放入方法区。最开始的步骤，更官方的说法是通过类的**全限定名**获取定义此类的**二进制字节流**。

   - 读入内存也就是加载（load）文件，这里的文件就是存在于网络或者物理存储中的文件，这个过程需要类加载器（ClassLoader）去实现。
   - 运行时的类信息，不仅包含类的基本信息，还包含**运行时常量池**信息，字符串字面量，数字常量，这些信息也是从 `.class` 文件中**常量池**这个部分读取或者说加载的。 
   - <font color="#fb5458">个人推断和理解</font>：方法区的class对象就是与static相关的这个对象，每个类只有一个，而实例肯定是不同的，没有新建实例的情况下，不可访问其属性。

2. **链接：**

   1. 验证：

      验证加载的 `.class` 文件中的字节流是否符合虚拟机要求，比如验证 `.class` 文件起始是否为**魔数**`CAFEBABE`，各个区域的语义，逻辑是否合乎规范等，有几个步骤（或者是种类的验证），但是感觉不大重要。
      
      - <font color="#fb5458">疑惑</font>：这里的描述是 `.class` 文件的字节流，但是第一步加载已经加载进内存了，这时验证是否不大合理？还是说是一遍加载一遍验证的，很怪。
   
   2. 准备：
   
      简单来说，是为**类变量**进行初始的**默认值**赋值，也就是 `static` 变量，根据其类型分别赋不同的值。<font color="#fb5458">这个过程也包含了内存分配的过程</font>
   
      - 但是对于 `final` 这种常量，在编译阶段，<font color="#fb5458">这个值大概会直接写好在 `.class` 内部</font>，然后这个时候直接显示初始化为该值，就没有默认值这一个说法了。
      - 至于为什么常量会在该阶段直接完成赋值操作，原因很简单：常量赋值过后不会被**修改**，所以直接在<font color="#fb5458">定义时</font>就给予值了。
   
   3. 解析：
   
      **常量池**内的符号引用转化为直接引用的过程？其中**符号引用**指用一组符号描述所引用的对象，引用目标不一定在内存中，而**直接引用**直接指向，如被引用目标在内存中的位置的指针，又或者是相对偏移量等。说实话这个解释没看懂。

3. **初始化**

   执行类构造器 `<clinit>()` 方法的过程。这个过程会自动收集类变量（ `static` 变量）的初始化语句，以及静态代码块的语句，整合到一起组成一个 `<clinit>()` 方法，然后执行。实际上就是初始化所有需要初始化的**变量**。

   - 需要注意的地方是，该方法按照代码语句顺序依次执行，常说的一种特殊例子，类似于先写静态代码块语句为还没有声明的类变量赋值，在下方才声明类变量，这个写法是可以的。原因在于，在**链接**阶段的准备环节，所有的类变量均已分配好内存空间，并赋予了初始值，那么在初始化阶段，这个类变量就会依次被静态代码块，自己声明的赋值所赋值，造成的结果就是静态代码块中的赋值没有用。*不过，如果不是赋值操作，那么编译器会报错（不能访问）*。
   - 如果没有类变量或者静态代码块，那么就不会生成  `<clinit>()` 方法，不过，对于 `<init>()` 一定会存在。并且，调用 `<clinit>()` 前，会调用其父类的  `<clinit>()` 方法。如果有多个线程都尝试加载同一个类时，需要加锁，不然内存中会存在两个class对象，并且这个对象也只会存在一个。

---

### 类加载器

<font color="#fb5458">可分为2大类，4小类</font>，两个大类指启动类加载器（Bootstrap）以及其他加载器，其原因是启动类加载器是C/C++编写的，其他的都继承于Java的类。

`应用程序类加载器 => 扩展类加载器 => 启动类加载器` ，按照层级，右侧的加载器成为**父**类加载器，注意是 **父** 加载器，而不是 **父类** 加载器，并不是**继承关系**。

- **启动类加载器/引导类加载器（Bootstrap）**：由C/C++实现，核心类库的加载器；
- **扩展类加载器（Extension）**：加载 `jre/lib/ext` 目录下的类；
- **应用程序类加载器/系统类加载器（Application）**：负责加载环境变量 `classpath` 或系统属性指定路径下的类库，一般自己写的类由这个加载器负责加载；
- 用户自定义类加载器：暂无；

### 双亲委派

按照层级，当前类加载器会不断地将加载任务交给**父**类加载器，直到顶层加载器，如果该加载器能够加载，则加载，不能就向下交给**子**类加载器加载。这样可以防止自己写的代码覆盖掉需要**启动类加载器**加载的核心类库，最常见的例子是自己写一个 `String` 类，并尝试加载。由此引出的概念是**沙箱安全机制**，即保护核心类库的代码不会被外部代码篡改。

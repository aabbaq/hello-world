# JVM

用来学习JVM的简略笔记，虽然已经有人做过了，但是不适合自己理解，因此还是自己写一些笔记比较好，有些内容抄的别人的资料，[配色方案](https://roselia.moe/blog/post/how-to-be-a-dd)也是抄的。总之<font color="#fb5458">红色部分的内容需要重新思考或者慎重的理解</font>，而且用的是标签的标记方法，可能等我摸透了扩展语法的内联公式再来修改吧。

- [别人的笔记](https://github.com/TangBean/understanding-the-jvm)

## 类加载

### 生命周期

```
加载阶段 --> 链接阶段 --> 初始化阶段
```

1. **加载：**

   这个过程会把字节码文件，即 `.class` 文件读入内存，并将其中的**静态结构**转化为**运行时数据结构**，生成的内存**class对象**放入方法区。最开始的步骤，更官方的说法是通过类的**全限定名**获取定义此类的**二进制字节流**。

   - 读入内存也就是加载（load）文件，这里的文件就是存在于网络或者物理存储中的文件，这个过程需要类加载器（ClassLoader）去实现。
   - 运行时的类信息，不仅包含类的基本信息，还包含**运行时常量池**信息，字符串字面量，数字常量，这些信息也是从 `.class` 文件中**常量池**这个部分读取或者说加载的。 
   - <font color="#fb5458">个人推断和理解</font>：方法区的class对象就是与static相关的这个对象，每个类只有一个，而实例肯定是不同的，没有新建实例的情况下，不可访问其属性。

2. **链接：**

   1. 验证：

      验证加载的 `.class` 文件中的字节流是否符合虚拟机要求，比如验证 `.class` 文件起始是否为**魔数**`CAFEBABE`，各个区域的语义，逻辑是否合乎规范等，有几个步骤（或者是种类的验证），但是感觉不大重要。
      
      - <font color="#fb5458">疑惑</font>：这里的描述是 `.class` 文件的字节流，但是第一步加载已经加载进内存了，这时验证是否不大合理？还是说是一遍加载一遍验证的，很怪。
   
   2. 准备：
   
      简单来说，是为**类变量**进行初始的**默认值**赋值，也就是 `static` 变量，根据其类型分别赋不同的值。<font color="#fb5458">这个过程也包含了内存分配的过程</font>
   
      - 但是对于 `final` 这种常量，在编译阶段，<font color="#fb5458">这个值大概会直接写好在 `.class` 内部</font>，然后这个时候直接显示初始化为该值，就没有默认值这一个说法了。
      - 至于为什么常量会在该阶段直接完成赋值操作，原因很简单：常量赋值过后不会被**修改**，所以直接在<font color="#fb5458">定义时</font>就给予值了。
   
   3. 解析：
   
      **常量池**内的符号引用转化为直接引用的过程？其中**符号引用**指用一组符号描述所引用的对象，引用目标不一定在内存中，而**直接引用**直接指向，如被引用目标在内存中的位置的指针，又或者是相对偏移量等。说实话这个解释没看懂。

3. **初始化**

   执行类构造器 `<clinit>()` 方法的过程。这个过程会自动收集类变量（ `static` 变量）的初始化语句，以及静态代码块的语句，整合到一起组成一个 `<clinit>()` 方法，然后执行。实际上就是初始化所有需要初始化的**变量**。

   - 需要注意的地方是，该方法按照代码语句顺序依次执行，常说的一种特殊例子，类似于先写静态代码块语句为还没有声明的类变量赋值，在下方才声明类变量，这个写法是可以的。原因在于，在**链接**阶段的准备环节，所有的类变量均已分配好内存空间，并赋予了初始值，那么在初始化阶段，这个类变量就会依次被静态代码块，自己声明的赋值所赋值，造成的结果就是静态代码块中的赋值没有用。*不过，如果不是赋值操作，那么编译器会报错（不能访问）*。
   - 如果没有类变量或者静态代码块，那么就不会生成  `<clinit>()` 方法，不过，对于 `<init>()` 一定会存在。并且，调用 `<clinit>()` 前，会调用其父类的  `<clinit>()` 方法。如果有多个线程都尝试加载同一个类时，需要加锁，不然内存中会存在两个class对象，并且这个对象也只会存在一个。

---

### 类加载器

<font color="#fb5458">可分为2大类，4小类</font>，两个大类指启动类加载器（Bootstrap）以及其他加载器，其原因是启动类加载器是C/C++编写的，其他的都继承于Java的类。

`应用程序类加载器 => 扩展类加载器 => 启动类加载器` ，按照层级，右侧的加载器成为**父**类加载器，注意是 **父** 加载器，而不是 **父类** 加载器，并不是**继承关系**。

- **启动类加载器/引导类加载器（Bootstrap）**：由C/C++实现，核心类库的加载器；
- **扩展类加载器（Extension）**：加载 `jre/lib/ext` 目录下的类；
- **应用程序类加载器/系统类加载器（Application）**：负责加载环境变量 `classpath` 或系统属性指定路径下的类库，一般自己写的类由这个加载器负责加载；
- 用户自定义类加载器：暂无；

### 双亲委派

按照层级，当前类加载器会不断地将加载任务交给**父**类加载器，直到顶层加载器，如果该加载器能够加载，则加载，不能就向下交给**子**类加载器加载。这样可以防止自己写的代码覆盖掉需要**启动类加载器**加载的核心类库，最常见的例子是自己写一个 `String` 类，并尝试加载。由此引出的概念是**沙箱安全机制**，即保护核心类库的代码不会被外部代码篡改。

---

## 运行时数据区

### Java线程

Java线程对应了操作系统的内核线程（Hotspot JVM）

---

### 程序计数器 （PC寄存器）

对物理寄存器的一种抽象，或者模拟，占用内存空间小，存在于每个线程中，程序计数器的作用是**行号指示**，存放下一条指令的地址（即将执行的指令代码）。

- 是唯一没有**OOM**的区域，也不会GC
- 既然是寄存器的模拟，那么程序计数器可以完成线程上下文切换的状态保存作用，这样就可以继续工作了

---

### 虚拟机栈

名称为Java虚拟机栈，由**栈帧**组成，每个栈帧对应一个Java方法。

- 存放**局部变量**，包含基本数据类型，或者对象的引用地址

- 指令集小，但完成操作需要的指令较多；采用栈的设计主要是为了跨平台。
- 不存在GC，但会OOM
- 可能出现两种异常：
  1. StackOverflowError：线程申请的栈空间超过了虚拟机栈允许的最大容量
  2. OutOfMemoryError：如果栈空间可以动态扩展，但内存中没有空间可以被扩展时；
- 可以使用 `-Xss SIZE`：设定虚拟机栈的大小，默认以字节作为单位，可以添加 `k m g` 来设置不同级别的的栈大小

#### 栈帧结构

1. 局部变量表（Local Variables）

   - **表大小**（长度）在编译完成后即确定，运行时**不会改变**；
   - LineNumberTable：字节码指令行号（Start PC）与代码行号的对应表；
   - LocalVariableTable：字节码指令行号表示声明变量的作用范围（下一行开始）；
   - 因为变量大小并不一定都一致，局部变量表内部，针对不同的变量需要占用不同空间，这个空间单位叫做**插槽（Slot）**，32位以内类型占用1个，64位占用2个；
     - 引用类型、与其他基本类型占用1个slot，并且能转化为int类型的其他类型转化为int类型
     - long、double占用2个slot；
   - 如果为**非静态**方法（构造方法，实例方法），需要增加实例的**this变量**至局部变量表内的**索引0**位置，即使有**形参**的声明，也是this在索引0位置
   - **重复利用**的优化：如果中间有局部变量的生命周期结束（比如局部变量中的局部变量），那么这个空余的插槽如果可以为后续的变量使用，那么分配给后续的变量以节省资源。

2. 操作数栈/表达式栈（Operand Stack）

   - 栈大小在编译后就确定了，操作数栈是一个数组结构

   - 保存计算过程的中间结果，可以看成一个临时的存储空间
   - 方法的返回值也会被保存在操作数栈中

3. 动态链接/指向运行时常量池的方法引用（Dynamic Link）

4. 方法返回地址（Return Address）

5. 其他

